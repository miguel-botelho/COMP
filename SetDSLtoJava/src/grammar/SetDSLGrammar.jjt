/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{	
  DEBUG_PARSER=false;
  LOOKAHEAD = 2;
}

PARSER_BEGIN(SetDSLGrammar)
package grammar;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.nio.charset.Charset;
import java.lang.String;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;

public class SetDSLGrammar
{
  public static ArrayList<Attribute> vars = new ArrayList<Attribute>();
  public static Boolean canRun = true;
  
  public static void main(String args [])
  {
	try
    {
		String ficheiro;
	    
		if ((ficheiro = readFile("files/input_file.txt")) == null)		{			System.out.println("Error reading file.");
			return;
		}
		InputStream stream = new ByteArrayInputStream(ficheiro.getBytes(Charset.forName("UTF-8")));

		System.out.print(ficheiro);
		SetDSLGrammar myDSL = new SetDSLGrammar(stream);
		
		SimpleNode n = myDSL.Start();
		if (canRun)
			runTree(n);
		System.out.println(vars);
     	n.dump("");
    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }

  public static Boolean createAttr(String var, int size, Boolean type, ArrayList<Integer> content)  {
	Attribute attr = new Attribute(var, size, type, content);
		
	vars.add(attr);
	return true;
  }

  public static Boolean checkOperations(String set, String set1, String set2) {
    if (!(checkType(set, false))) //false é output
    {
  		System.out.println("O Set " + set + " não é do tipo Output.");
  		return false;
  	}
  	if (!(checkType(set1, true))) //true é input
  	{
		System.out.println("O Set " + set1 + " não é do tipo Input.");
  		return false;
  	}
  	if (!(checkType(set2, true))) //true é input
  	{
		System.out.println("O Set " + set2 + " não é do tipo Input.");
  		return false;
  	}
	return true;
   }

  /* LIST BEGIN */
  public static ArrayList<Integer> shrinkList(ArrayList<Integer> arr, Integer size) {
	ArrayList<Integer> ret = new ArrayList<Integer>(size);
	for (int i = 0; i < size & i < arr.size(); i++) {
		ret.add(arr.get(i));
	}
	return ret;
  }

  public static void changeContent(String var, ArrayList<Integer> content) {
	for (int i = 0; i < vars.size(); i++) {
		  if (vars.get(i).getVariable().equals(var))
		  	vars.get(i).setContent(content);
		}
  }

  public static Boolean existsVar(String var) {
	for (int i = 0; i < vars.size(); i++) {
		  if (vars.get(i).getVariable().equals(var))
		  	return true;
		}
	return false;
  }

  public static Attribute returnAttr(String var) {
	for (int i = 0; i < vars.size(); i++) {
		  if (vars.get(i).getVariable().equals(var))
		  	return vars.get(i);
		}
	return null;
  }
    
  public static Boolean checkType(String var, Boolean type) {
	for (int i = 0; i < vars.size(); i++) {
		  if (vars.get(i).getVariable().equals(var))
		  	return vars.get(i).getType() == type;
		}
	return false;
  }
  /* LIST END */
  /* OPERATIONS BEGIN */  
  public static ArrayList<Integer> intersection(String destSet, String set, String set1) {
	Attribute attr = returnAttr(set);
	Attribute attr1 = returnAttr(set1);

	ArrayList<Integer> ret = new ArrayList<Integer>();
	Integer size = 1;

	for (int i = 0; i < attr1.getContent().size(); i++) {
		if (attr.getContent().contains(attr1.getContent().get(i)))
			ret.add(attr1.getContent().get(i));
	}
	for (int i = 0; i < vars.size(); i++) {
		if (vars.get(i).getVariable().equals(destSet))
			size = vars.get(i).getSize();
	}
	
	return shrinkList(ret, size);
  }

  public static ArrayList<Integer> union(String destSet, String set, String set1) {
	Attribute attr = returnAttr(set);
	Attribute attr1 = returnAttr(set1);

	ArrayList<Integer> ret = attr.copyContent();
	Integer size = 1;

	for (int i = 0; i < attr1.getContent().size(); i++) {
		if (!(ret.contains(attr1.getContent().get(i))))
			ret.add(attr1.getContent().get(i));
	}

	for (int i = 0; i < vars.size(); i++) {		if (vars.get(i).getVariable().equals(destSet))
			size = vars.get(i).getSize();
	}
	return shrinkList(ret, size);
  }

  public static ArrayList<Integer> concat(String destSet, String set, String set1) {
	Attribute attr = returnAttr(set);
	Attribute attr1 = returnAttr(set1);

	ArrayList<Integer> ret = attr.copyContent();
	Integer size = 1;

	for (int i = 0; i < attr1.getContent().size(); i++) {
		ret.add(attr1.getContent().get(i));
	}

	for (int i = 0; i < vars.size(); i++) {
		if (vars.get(i).getVariable().equals(destSet))
			size = vars.get(i).getSize();
	}
	return shrinkList(ret, size);
  }

  public static ArrayList<Integer> difference(String destSet, String set, String set1) {
	Attribute attr = returnAttr(set);
	Attribute attr1 = returnAttr(set1);

	ArrayList<Integer> ret = attr.copyContent();
	Integer size = 1;

	for (int i = 0; i < attr1.getContent().size(); i++) {
	  	if (ret.contains(attr1.getContent().get(i)))
			ret.remove(ret.indexOf(attr1.getContent().get(i)));
	}

	for (int i = 0; i < vars.size(); i++) {
		if (vars.get(i).getVariable().equals(destSet))
			size = vars.get(i).getSize();
	}
	return shrinkList(ret, size);
  }

  public static ArrayList<Integer> subset(String destSet, String set, String set1) {
	Attribute attr = returnAttr(set);
	Attribute attr1 = returnAttr(set1);

	ArrayList<Integer> ret = attr.copyContent();
	Integer size = 1;

	for (int i = 0; i < vars.size(); i++) {
		if (vars.get(i).getVariable().equals(destSet))
			size = vars.get(i).getSize();
	}
	return shrinkList(ret, size);
  }
  /* OPERATIONS END */

  public static String readFile(String fileName) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader(fileName));
    try {
        StringBuilder sb = new StringBuilder();
        String line = br.readLine();

        while (line != null) {
            sb.append(line);
            sb.append("\n");
            line = br.readLine();
        }
        return sb.toString();
    } finally {
        br.close();
    }
  }

  public static void runTree(SimpleNode n)  {	for (int i = 0; i < n.jjtGetNumChildren(); i++)
    {
      SimpleNode temp = (SimpleNode) n.jjtGetChild(i);
	  runChild(temp);
    }
  }

  public static void runChild(SimpleNode n)  {	String var = "";
	  Integer size = 0;
	  Boolean type = true;
	  ArrayList<Integer > vals = new ArrayList<Integer>();
	  for (int i = 0; i < n.jjtGetNumChildren(); i++)
	  {
		SimpleNode novo = (SimpleNode) n.jjtGetChild(i);
		//tipo
		if (novo.getVal().equals("Input"))
			type = true;
		else if (novo.getVal().equals("Output"))
			type = false;
		//size
		else if (isNumeric(novo.getVal()))
			size = Integer.parseInt(novo.getVal());
		else if (novo.getVal() != "")
			var = novo.getVal();
		else		{		  vals = novo.getVals();
		  size = vals.size();
		}
	  }
	  createAttr(var, size, type, vals);
  }
  
  public static boolean isNumeric(String str)  {  
	  try  
	  {  
	    double d = Double.parseDouble(str);  
	  }  
	  catch(NumberFormatException nfe)  
	  {  
	    return false;  
	  }  
	  return true;  
  }

}

PARSER_END(SetDSLGrammar)

SKIP:
{
  " " | "\r" | "\t"
}

TOKEN:
{
  	< POINT : "." >
 	| < EQUALS : "=" >
	| < OPERATION : "int"|"+"|"diff"|"sub"|"concat" >
 	| < VALUES : ([ "0"-"9" ])+","([ "0"-"9" ])+(","([ "0"-"9" ])+)* >
    | < INTEGER : ([ "0"-"9" ])+ >
	| < LF : "\n" >
	| < TYPE : "Input"|"Output" >
	| < IS_EMPTY : "is_empty()" >
	| < ITERATE : "iterate()" >
	| < ENUMERATE : "enumerate()" >
	| < SORT : "sort()" >
	| < CAPACITY : "capacity()" >
	| < POP : "pop()" >
	| < CLEAR : "clear()" >
	| < SUM : "sum()" >
	| < MIN : "min()" >
	| < MAX : "max()" >
	| < CHAR : [ "A"-"Z", "a"-"z" ]([ "0"-"9", "a"-"z", "A"-"Z" ])* >	
}

SimpleNode Start():
{}
{
  /*
  ((Atributions() < LF >) | (MethodsNoArguments() < LF >) | (Operations() < LF >) | (MethodsArguments() < LF >))*  {
	return jjtThis;
  }
  */
  StartOfFile()
  //((Att_size() < LF >) | (Att_empty() < LF >) | (Att() < LF >))*
  ((Att() < LF >))
  EndOfFile()
  {	return jjtThis;
  }
}
//
void EndOfFile() #void:
{}
{	"*/"
}
void StartOfFile() #void:
{}
{  "/* @SETDSL" < LF >}

void Att_size() :
{
  Token t;
}
{  	t = < TYPE >
	{
	  switch(t.image)
	  {
	    case "Input":
		{
		  String t1 = Token(); //0 Input
		  Integer s = Size();
		  if (existsVar(t1))
		  {
			System.out.println("A variável " + t1 + " já existe.");
			canRun = false;
	 	  }
		  break;
		}
		case "Output":
		{
		  String t1 = Token(); //1 Output
		  Integer s = Size();
		  if (existsVar(t1))
		  {
			System.out.println("A variável " + t1 + " já existe.");
			canRun = false;
	 	  }
		  break;
		}
		default:
		{
		  break;
		}	
	  }
	} #Intro	{
	  SimpleNode no = (SimpleNode) jjtThis.jjtGetChild(0);
	  no.val = t.image;	}
}
//
void Att_empty():
{	Token t;
}
{	t = < TYPE >
	{
	  switch(t.image)	  {	    case "Input":
		{
		  String t1 = Token_empty(); //0 Input
		  if (existsVar(t1))
		  {
			System.out.println("A variável " + t1 + " já existe.");
			canRun = false;
	 	  }
		  break;
		}
		case "Output":
		{
		  String t1 = Token(); //1 Output
		  if (existsVar(t1))
		  {
			System.out.println("A variável " + t1 + " já existe.");
			canRun = false;
	 	  }
		  break;
		}
		default:
		{
		  break;
		}	
	  }
	} #Intro
	{
	  SimpleNode no = (SimpleNode) jjtThis.jjtGetChild(0);
	  no.val = t.image;
	}
}
//

void Att():
{	Token t;
}
{
  t = < TYPE >
  {	switch(t.image) {		case "Input":		{
		  String t1 = Token(); //0 Input
		  ArrayList<Integer> arr = Vals();//
		  if (existsVar(t1))
		  {
			System.out.println("A variável " + t1 + " já existe.");
			canRun = false;
	 	  }
		  break;		}
		case "Output":		{
		  String t1 = Token(); //1 Output
		  ArrayList<Integer> arr = Vals();//
		  if (existsVar(t1))
		  {
			System.out.println("A variável " + t1 + " já existe.");
			canRun = false;
	 	  }
		  break;		}
		default:		{
		  break;		}	
	}
  } #Intro
  	{
	  SimpleNode no = (SimpleNode) jjtThis.jjtGetChild(0);
	  no.val = t.image;
	}
}
//
String Token() #Token:
{	Token ch;
}
{	ch = < CHAR > ":" "Set("
	{		jjtThis.val = ch.image;
	}
	{		return ch.image;
	}	
}

String Token_empty() #Token:
{
	Token ch;
}
{
	ch = < CHAR > ":" "Set();"
	{
		jjtThis.val = ch.image;
	}
	{
		return ch.image;
	}
	
}

Integer Size():
{	Token s;
}
{	s = < INTEGER > ");"
	{  
		jjtThis.val = s.image;
	}
	{
	 	String set = s.image;
		return Integer.parseInt(s.image);  	}	   
}


ArrayList<Integer> Vals() #Values:
{	Token vals;
}
{
  vals = < VALUES > ");"
  {
	  String[] valores = vals.image.split(",");
	  	ArrayList<Integer> val = new ArrayList<Integer>();
	
	  	for (int i = 0; i < valores.length; i++) {
			val.add(Integer.parseInt(valores[i]));
	  	}
	  	jjtThis.vals = val;
	  	return val;
   }
   
}

void Atributions():
{
	Token ch, tam, tipo;
}{
  	// Criar Sets vazios  	(tipo = < TYPE > ch = < CHAR > ":" "Set();"
    {
        switch (tipo.image) {
			case "Input":
			if (!(createAttr(ch.image, 0, true, new ArrayList<Integer>())))
				System.exit(0);
			break;
			case "Output":
			if (!(createAttr(ch.image, 0, false, new ArrayList<Integer>())));
				System.exit(0);
			break;
			default:
			break;
		}
    })
    | (tipo = < TYPE > ch = < CHAR > ":" "Set(" tam = < VALUES > ");" // Criar sets com valores já definidos
    {
      	String[] valores = tam.image.split(",");
      	ArrayList<Integer> vals = new ArrayList<Integer>();

      	for (int i = 0; i < valores.length; i++) {			vals.add(Integer.parseInt(valores[i]));
      	}
		switch (tipo.image)
		{
			case "Input":
			if (!(createAttr(ch.image, valores.length, true, vals)))
				System.exit(0);
			break;
			case "Output":
			if (!(createAttr(ch.image, valores.length, false, vals)))
				System.exit(0);
			break;
			default:
			break;
		}
    }) 
    | (tipo = < TYPE > ch = < CHAR > ":" "Set(" tam = < INTEGER > ");" // Criar Sets com tamanho
    {
       ArrayList<Integer> vals1 = new ArrayList<Integer>(Integer.parseInt(tam.image)); //
       switch (tipo.image)
		{
			case "Input":
			if (!(createAttr(ch.image, Integer.parseInt(tam.image), true, vals1)))
				System.exit(0);
			break;
			case "Output":
			if (!(createAttr(ch.image, Integer.parseInt(tam.image), false, vals1)));
				return; //TODO se meter System.exit(0) aqui, não mostra os prints que a função createAttr chama
			break;
			default:
			break;
		}
    })
}

void Operations():
{	Token set, set1, op, set2, eq;
}
{	(set = < CHAR > eq = < EQUALS > set1 = < CHAR > op = < OPERATION > set2 = < CHAR > ";"
	{
	  	if (!(checkOperations(set.image, set1.image, set2.image)))
	  		System.exit(0);		switch (op.image) {
			case "int":
			changeContent(set.image, intersection(set.image, set1.image, set2.image));
			break;
			case "+":
			changeContent(set.image, union(set.image, set1.image, set2.image));
			break;
			case "diff":
			changeContent(set.image, difference(set.image, set1.image, set2.image));
			break;
			case "concat":
			changeContent(set.image, concat(set.image, set1.image, set2.image));
			break;
			default:
			break; 
		}		  
	})
}

void MethodsNoArguments():
{
	Token set, method, pt;
}
{
	(set = < CHAR > pt = < POINT > method = < IS_EMPTY > ";"
    {

    })
    | (set = < CHAR > pt = < POINT > method = < ITERATE > ";"
    {
      
    })
    | (set = < CHAR > pt = < POINT > method = < ENUMERATE > ";"
    {

    })
    | (set = < CHAR > pt = < POINT > method = < SORT > ";"
    {

    })
    | (set = < CHAR > pt = < POINT > method = < CAPACITY > ";"
    {

    })
    | (set = < CHAR > pt = < POINT > method = < POP > ";"
    {

    })
    | (set = < CHAR > pt = < POINT > method = < CLEAR > ";"
    {

    })
    | (set = < CHAR > pt = < POINT > method = < SUM > ";"
    {

    })
    | (set = < CHAR > pt = < POINT > method = < MAX > ";"
    {

    })
    | (set = < CHAR > pt = < POINT > method = < MIN > ";"
    {

    })
}

void MethodsArguments():
{
	Token set, num, set1, pt;
}
{
    (set = < CHAR > pt = < POINT > "add(" num = < INTEGER > ");"
    {

    })
    | (set = < CHAR > pt = < POINT > "remove(" num = < INTEGER > ");"
    {

    }) 
	| (set = < CHAR > pt = < POINT > "equals(" set1 = < CHAR > ");"
	{

	})
    | (set = < CHAR > pt = < POINT > "is_element(" num = < INTEGER > ");"
    {

    })
    | (set = < CHAR > "sub" set1 = < CHAR > ";"
    {		
    })
}