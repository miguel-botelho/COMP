/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{	
  DEBUG_PARSER=false;
  LOOKAHEAD = 5;
}

PARSER_BEGIN(SetDSLGrammar)
package grammar;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.nio.charset.Charset;
import java.lang.String;
import java.util.ArrayList;

public class SetDSLGrammar
{
  public static ArrayList<Attribute> vars = new ArrayList<Attribute>();
  
  public static void main(String args [])
  {
	try
    {
		String ficheiro;
	    
		if ((ficheiro = readFile("files/input_file.txt")) == null)		{			System.out.println("Error reading file.");
			return;
		}
		InputStream stream = new ByteArrayInputStream(ficheiro.getBytes(Charset.forName("UTF-8")));

		System.out.print(ficheiro);
		SetDSLGrammar myDSL = new SetDSLGrammar(stream);
		
		SimpleNode n = myDSL.Start();
		System.out.println(vars);
     	n.dump("");
    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }

  public static Boolean createAttr(String var, int size, Boolean type, ArrayList<Integer> content)  {
	Attribute attr = new Attribute(var, size, type, content);

	if (existsVar(var))
		return false;
		
	vars.add(attr);
	return true;
  }

  public static Boolean checkOperations(String set, String set1, String set2) {
    if (!(checkType(set, false))) //false é output
    {
  		System.out.println("O Set " + set + " não é do tipo Output.");
  		return false;
  	}
  	if (!(checkType(set1, true))) //true é input
  	{
		System.out.println("O Set " + set1 + " não é do tipo Input.");
  		return false;
  	}
  	if (!(checkType(set2, true))) //true é input
  	{
		System.out.println("O Set " + set2 + " não é do tipo Input.");
  		return false;
  	}
	return true;
   }

  /* LIST BEGIN */
  public static ArrayList<Integer> shrinkList(ArrayList<Integer> arr, Integer size) {
	ArrayList<Integer> ret = new ArrayList<Integer>(size);
	for (int i = 0; i < size & i < arr.size(); i++) {
		ret.add(arr.get(i));
	}
	return ret;
  }

  public static void changeContent(String var, ArrayList<Integer> content) {
	for (int i = 0; i < vars.size(); i++) {
		  if (vars.get(i).getVariable().equals(var))
		  	vars.get(i).setContent(content);
		}
  }

  public static Boolean existsVar(String var) {
	for (int i = 0; i < vars.size(); i++) {
		  if (vars.get(i).getVariable().equals(var))
		  	return true;
		}
	return false;
  }

  public static Attribute returnAttr(String var) {
	for (int i = 0; i < vars.size(); i++) {
		  if (vars.get(i).getVariable().equals(var))
		  	return vars.get(i);
		}
	return null;
  }
    
  public static Boolean checkType(String var, Boolean type) {
	for (int i = 0; i < vars.size(); i++) {
		  if (vars.get(i).getVariable().equals(var))
		  	return vars.get(i).getType() == type;
		}
	return false;
  }
  /* LIST END */
  /* OPERATIONS BEGIN */  
  public static ArrayList<Integer> intersection(String destSet, String set, String set1) {
	Attribute attr = returnAttr(set);
	Attribute attr1 = returnAttr(set1);

	ArrayList<Integer> ret = new ArrayList<Integer>();
	Integer size = 1;

	for (int i = 0; i < attr1.getContent().size(); i++) {
		if (attr.getContent().contains(attr1.getContent().get(i)))
			ret.add(attr1.getContent().get(i));
	}
	for (int i = 0; i < vars.size(); i++) {
		if (vars.get(i).getVariable().equals(destSet))
			size = vars.get(i).getSize();
	}
	
	return shrinkList(ret, size);
  }

  public static ArrayList<Integer> union(String destSet, String set, String set1) {
	Attribute attr = returnAttr(set);
	Attribute attr1 = returnAttr(set1);

	ArrayList<Integer> ret = attr.copyContent();
	Integer size = 1;

	for (int i = 0; i < attr1.getContent().size(); i++) {
		if (!(ret.contains(attr1.getContent().get(i))))
			ret.add(attr1.getContent().get(i));
	}

	for (int i = 0; i < vars.size(); i++) {		if (vars.get(i).getVariable().equals(destSet))
			size = vars.get(i).getSize();
	}
	return shrinkList(ret, size);
  }

  public static ArrayList<Integer> difference(String destSet, String set, String set1) {
	Attribute attr = returnAttr(set);
	Attribute attr1 = returnAttr(set1);

	ArrayList<Integer> ret = attr.copyContent();
	Integer size = 1;

	for (int i = 0; i < attr1.getContent().size(); i++) {
	  	if (ret.contains(attr1.getContent().get(i)))
			ret.remove(ret.indexOf(attr1.getContent().get(i)));
	}

	for (int i = 0; i < vars.size(); i++) {
		if (vars.get(i).getVariable().equals(destSet))
			size = vars.get(i).getSize();
	}
	return shrinkList(ret, size);
  }

  public static ArrayList<Integer> subset(String destSet, String set, String set1) {
	Attribute attr = returnAttr(set);
	Attribute attr1 = returnAttr(set1);

	ArrayList<Integer> ret = attr.copyContent();
	Integer size = 1;

	for (int i = 0; i < vars.size(); i++) {
		if (vars.get(i).getVariable().equals(destSet))
			size = vars.get(i).getSize();
	}
	return shrinkList(ret, size);
  }
  /* OPERATIONS END */

  public static String readFile(String fileName) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader(fileName));
    try {
        StringBuilder sb = new StringBuilder();
        String line = br.readLine();

        while (line != null) {
            sb.append(line);
            sb.append("\n");
            line = br.readLine();
        }
        return sb.toString();
    } finally {
        br.close();
    }
	}

}

PARSER_END(SetDSLGrammar)

SKIP:
{
  " " | "\r" | "\t"
}

TOKEN:
{
  	< VALUES : ([ "0"-"9" ])+","([ "0"-"9" ])+(","([ "0"-"9" ])+)* >
    | < INTEGER : ([ "0"-"9" ])+ >
	| < LF : "\n" >
	| < TYPE : "Input"|"Output" > // feito
	| < END : "end" >
	| < OPERATION : "int"|"union"|"diff"|"sub" >
	| < IS_EMPTY : "is_empty()" >
	| < ITERATE : "iterate()" >
	| < ENUMERATE : "enumerate()" >
	| < SORT : "sort()" >
	| < CAPACITY : "capacity()" >
	| < POP : "pop()" >
	| < CLEAR : "clear()" >
	| < SUM : "sum()" >
	| < MIN : "min()" >
	| < MAX : "max()" >
	| < CHAR : [ "A"-"Z", "a"-"z" ]([ "0"-"9", "a"-"z", "A"-"Z" ])* >	
}

SimpleNode Start() :
{}
{
  (< CHAR > )* 
  StartOfFile()

  ((Atributions() < LF >) | (Operations() < LF >) | (Methods() < LF >))*
  EndOfFile()  {
	return jjtThis;
  }
  (< CHAR >)*
  
}


void Atributions() #void:
{
	Token ch, tam, tipo;
}{  	(tipo = < TYPE > ch = < CHAR > ":" "Set();"
    {
        switch (tipo.image) {
			case "Input":
			if (!(createAttr(ch.image, 0, true, new ArrayList<Integer>())))
				return;
			break;
			case "Output":
			if (!(createAttr(ch.image, 0, false, new ArrayList<Integer>())));
				return;
			break;
			default:
			break;
		}
    })
    | (tipo = < TYPE > ch = < CHAR > ":" "Set(" tam = < VALUES > ");"
    {
      	String[] valores = tam.image.split(",");
      	ArrayList<Integer> vals = new ArrayList<Integer>();

      	for (int i = 0; i < valores.length; i++) {			vals.add(Integer.parseInt(valores[i]));
      	}
		switch (tipo.image)
		{
			case "Input":
			if (!(createAttr(ch.image, valores.length, true, vals)))
				return;
			break;
			case "Output":
			if (!(createAttr(ch.image, valores.length, false, vals)))
				return;
			break;
			default:
			break;
		}
    }) 
    | (tipo = < TYPE > ch = < CHAR > ":" "Set(" tam = < INTEGER > ");"
    {
       switch (tipo.image)
		{
			case "Input":
			if (!(createAttr(ch.image, Integer.parseInt(tam.image), true, new ArrayList<Integer>(Integer.parseInt(tam.image)))))
				return;
			break;
			case "Output":
			if (!(createAttr(ch.image, Integer.parseInt(tam.image), false, new ArrayList<Integer>(Integer.parseInt(tam.image)))));
				return;
			break;
			default:
			break;
		}
    })
}

void Operations() #void:
{	Token set, set1, op, set2;
}
{	(set = < CHAR > "=" set1 = < CHAR > op = < OPERATION > set2 = < CHAR > ";"
	{
	  	if (!(checkOperations(set.image, set1.image, set2.image)))
	  		return;		switch (op.image) {
			case "int":
			changeContent(set.image, intersection(set.image, set1.image, set2.image));
			break;
			case "union":
			changeContent(set.image, union(set.image, set1.image, set2.image));
			break;
			case "diff":
			changeContent(set.image, difference(set.image, set1.image, set2.image));
			break;
			case "sub":
			changeContent(set.image, subset(set.image, set1.image, set2.image));
			break;
			default:
			break; 
		}		  
	})
}

void Methods() #void:
{
	Token set, method, num, set1;
}
{
	(set = < CHAR > "." method = < IS_EMPTY > ";"
    {

    })
    | (set = < CHAR > "." method = < ITERATE > ";"
    {
      
    })
    | (set = < CHAR > "." method = < ENUMERATE > ";"
    {

    })
    | (set = < CHAR > "." "add(" num = < INTEGER > ");"
    {

    })
    | (set = < CHAR > "." "remove(" num = < INTEGER > ");"
    {

    }) 
	| (set = < CHAR > "." "equals(" set1 = < CHAR > ");"
	{

	})
    | (set = < CHAR > "." "is_element(" num = < INTEGER > ");"
    {

    })
    | (set = < CHAR > "." method = < SORT > ";"
    {

    })
    | (set = < CHAR > "." method = < CAPACITY > ";"
    {

    })
    | (set = < CHAR > "." method = < POP > ";"
    {

    })
    | (set = < CHAR > "." method = < CLEAR > ";"
    {

    })
    | (set = < CHAR > "." method = < SUM > ";"
    {

    })
    | (set = < CHAR > "." method = < MAX > ";"
    {

    })
    | (set = < CHAR > "." method = < MIN > ";"
    {

    })
}

void StartOfFile() #void:{}
{	"/* @SETDSL" < LF >
}

void EndOfFile() #void:{}
{
	"*/"
}